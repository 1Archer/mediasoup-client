const sdpTransform = require('sdp-transform');

/**
 * Extract RTP capabilities from a SDP.
 *
 * @param {Object} sdpObj - SDP Object generated by sdp-transform.
 *
 * @returns {RTCRtpCapabilities}
 */
exports.extractRtpCapabilities = function({ sdpObj })
{
	// Map of RtpCodecParameters indexed by payload type.
	const codecsMap = new Map();

	// Array of RtpHeaderExtensions.
	const headerExtensions = [];

	// Whether a m=audio/video section has been already found.
	let gotAudio = false;
	let gotVideo = false;

	for (const m of sdpObj.media)
	{
		const kind = m.type;

		switch (kind)
		{
			case 'audio':
			{
				if (gotAudio)
					continue;

				gotAudio = true;

				break;
			}
			case 'video':
			{
				if (gotVideo)
					continue;

				gotVideo = true;

				break;
			}
			default:
			{
				continue;
			}
		}

		// Get codecs.
		for (const rtp of m.rtp)
		{
			const codec =
			{
				name                 : rtp.codec,
				mimeType             : `${kind}/${rtp.codec}`,
				kind                 : kind,
				clockRate            : rtp.rate,
				preferredPayloadType : rtp.payload,
				channels             : rtp.encoding,
				rtcpFeedback         : [],
				parameters           : {}
			};

			if (codec.kind !== 'audio')
				delete codec.channels;
			else if (!codec.channels)
				codec.channels = 1;

			codecsMap.set(codec.preferredPayloadType, codec);
		}

		// Get codec parameters.
		for (const fmtp of m.fmtp || [])
		{
			const parameters = sdpTransform.parseFmtpConfig(fmtp.config);
			const codec = codecsMap.get(fmtp.payload);

			if (!codec)
				continue;

			codec.parameters = parameters;
		}

		// Get RTCP feedback for each codec.
		for (const fb of m.rtcpFb || [])
		{
			const codec = codecsMap.get(fb.payload);

			if (!codec)
				continue;

			const feedback =
			{
				type      : fb.type,
				parameter : fb.subtype
			};

			if (!feedback.parameter)
				delete feedback.parameter;

			codec.rtcpFeedback.push(feedback);
		}

		// Get RTP header extensions.
		for (const ext of m.ext || [])
		{
			const headerExtension =
			{
				kind        : kind,
				uri         : ext.uri,
				preferredId : ext.value
			};

			headerExtensions.push(headerExtension);
		}
	}

	const rtpCapabilities =
	{
		codecs           : Array.from(codecsMap.values()),
		headerExtensions : headerExtensions,
		fecMechanisms    : [] // TODO
	};

	return rtpCapabilities;
};

/**
 * Extract DTLS parameters from a SDP.
 *
 * @param {Object} sdpObj - SDP Object generated by sdp-transform.
 *
 * @returns {RTCDtlsParameters}
 */
exports.extractDtlsParameters = function({ sdpObj })
{
	const media = getFirstActiveMediaSection(sdpObj);
	const fingerprint = media.fingerprint || sdpObj.fingerprint;
	let role;

	switch (media.setup)
	{
		case 'active':
			role = 'client';
			break;
		case 'passive':
			role = 'server';
			break;
		case 'actpass':
			role = 'auto';
			break;
	}

	const dtlsParameters =
	{
		role         : role,
		fingerprints :
		[
			{
				algorithm : fingerprint.type,
				value     : fingerprint.hash
			}
		]
	};

	return dtlsParameters;
};

/**
 * Set codec sending or receiving parameters by mangling the SDP.
 *
 * @param {Object} sdpObj - SDP Object generated by sdp-transform.
 * @param {String} direction - 'send' or 'recv'.
 * @param {String} [mid] - MID value.
 * @param {MediaStreamTrack} [track]
 * @param {String} [kind] - 'audio' or 'video'.
 * @param {RTCRtpParameters} rtpParameters
 * @param {Boolean} [opusStereo] - Whether to enable stereo in OPUS.
 * @param {Boolean} [opusFec] - Whether to enable in-band FEC in OPUS.
 * @param {Boolean} [opusDtx] - Whether to enable DTX in OPUS.
 * @param {Number} [opusMaxPlaybackRate] - Max playback rate in OPUS.
 */
exports.setCodecParameters = function(
	{
		sdpObj,
		direction,
		mid,
		track,
		kind,
		rtpParameters,
		opusStereo,
		opusFec,
		opusDtx,
		opusMaxPlaybackRate
	}
)
{
	if (direction !== 'send' && direction !== 'recv')
		throw new TypeError('wrong/missing direction');

	const mSection = findMediaSection({ sdpObj, mid, track, kind });

	if (!mSection)
		throw Error(`media section with mid "${mid}" not found`);

	for (const codec of rtpParameters.codecs)
	{
		const rtp = (mSection.rtp || []).find((r) => r.payload === codec.payloadType);

		if (!rtp)
			continue;

		// Just in case.
		mSection.fmtp = mSection.fmtp || [];

		let fmtp = mSection.fmtp.find((f) => f.payload === codec.payloadType);

		if (!fmtp)
		{
			fmtp = { payload: codec.payloadType, config: '' };
			mSection.fmtp.push(fmtp);
		}

		const params = sdpTransform.parseParams(fmtp.config);

		switch (codec.mimeType.toLowerCase())
		{
			case 'audio/opus':
			{
				if (opusStereo !== undefined)
				{
					if (direction === 'send')
					{
						params['sprop-stereo'] = opusStereo ? 1 : 0;
						codec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;
					}
					else
					{
						params.stereo = opusStereo ? 1 : 0;
					}
				}

				if (opusFec !== undefined)
				{
					if (direction === 'send')
					{
						params.useinbandfec = opusFec ? 1 : 0;
						codec.parameters.useinbandfec = opusFec ? 1 : 0;
					}
					else
					{
						params.useinbandfec = opusFec ? 1 : 0;
					}
				}

				if (opusDtx !== undefined)
				{
					if (direction === 'send')
					{
						params.usedtx = opusDtx ? 1 : 0;
						codec.parameters.usedtx = opusDtx ? 1 : 0;
					}
					else
					{
						params.usedtx = opusDtx ? 1 : 0;
					}
				}

				if (opusMaxPlaybackRate !== undefined)
				{
					if (direction === 'send')
					{
						params.maxplaybackrate = opusMaxPlaybackRate;
						codec.parameters.maxplaybackrate = opusMaxPlaybackRate;
					}
					else
					{
						params.maxplaybackrate = opusMaxPlaybackRate;
					}
				}

				break;
			}
		}

		// Write the codec fmtp.config back.
		fmtp.config = '';

		for (const key of Object.keys(params))
		{
			if (fmtp.config)
				fmtp.config += ';';

			fmtp.config += `${key}=${params[key]}`;
		}
	}
};

function getFirstActiveMediaSection(sdpObj)
{
	return (sdpObj.media || [])
		.find((m) => m.iceUfrag && m.port !== 0);
}

function findMediaSection({ sdpObj, mid, track, kind })
{
	let mSection;

	if (mid !== null && mid !== undefined)
	{
		mid = String(mid);

		mSection = (sdpObj.media || [])
			.find((m) => String(m.mid) === mid);

		if (!mSection)
			throw new Error(`SDP section with mid=${mid} not found`);
	}
	else if (track)
	{
		// Look for a=msid.
		mSection = (sdpObj.media || [])
			.find((m) => (
				m.type === track.kind &&
				m.msid &&
				m.msid.split(' ')[1] === track.id
			));

		if (!mSection)
			throw new Error(`SDP section with a=msid containing track.id=${track.id} not found`);
	}
	else if (kind)
	{
		mSection = (sdpObj.media || [])
			.find((m) => m.type === kind);

		if (!mSection)
			throw new Error(`SDP section with kind=${kind} not found`);
	}
	else
	{
		throw new TypeError('missing mid, track and kind');
	}

	return mSection;
}
