/**
 * Fill the given RTP parameters for the given track.
 *
 * NOTE: Currently it assumes a single encoding (no simulcast).
 *
 * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.
 * @param {Object} sdpObj - Local SDP Object generated by sdp-transform.
 * @param {MediaStreamTrack} track
 */
export function fillRtpParametersForTrack(rtpParameters, sdpObj, track)
{
	const kind = track.kind;
	let ssrc;
	const encoding = {};
	const rtcp =
	{
		cname       : null,
		reducedSize : true,
		mux         : true
	};

	const mSection = (sdpObj.media || [])
		.find((m) => m.type === kind);

	if (!mSection)
		throw new Error(`m=${kind} section not found`);

	// Get the SSRC.

	const ssrcMsidLine = (mSection.ssrcs || [])
		.find((line) =>
		{
			if (line.attribute !== 'msid')
				return false;

			const trackId = line.value.split(' ')[1];

			if (trackId === track.id)
				return true;
		});

	if (!ssrcMsidLine)
		throw new Error(`a=ssrc line not found for local track [track.id:${track.id}]`);

	ssrc = ssrcMsidLine.id;
	encoding.ssrc = ssrc;

	// Get the SSRC for RTX.

	(mSection.ssrcGroups || [])
		.some((line) =>
		{
			if (line.semantics !== 'FID')
				return;

			const ssrcs = line.ssrcs.split(/[ ]+/);

			if (Number(ssrcs[0]) === ssrc)
			{
				const rtxSsrc = Number(ssrcs[1]);

				encoding.rtx = { ssrc: rtxSsrc };

				return true;
			}
		});

	// Get RTCP info.

	const ssrcCnameLine = mSection.ssrcs
		.find((line) =>
		{
			return (line.attribute === 'cname' && line.id === ssrc);
		});

	if (ssrcCnameLine)
		rtcp.cname = ssrcCnameLine.value;

	// Fill RTP parameters.
	rtpParameters.encodings = [ encoding ];
	rtpParameters.rtcp = rtcp;
}
