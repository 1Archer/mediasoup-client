import sdpTransform from 'sdp-transform';

/**
 * Extract RTP capabilities from a SDP.
 *
 * @param {Object} sdpObject - SDP Object generated by sdp-transform.
 * @return {RTCRtpCapabilities}
 */
export function extractRtpCapabilities(sdpObject)
{
	// Map of RtpCodecParameters indexed by payload type.
	const codecsMap = new Map();

	// Array of RtpHeaderExtensions.
	const headerExtensions = [];

	// Whether a m=audio/video section has been already found.
	let gotAudio = false;
	let gotVideo = false;

	for (const m of sdpObject.media)
	{
		const kind = m.type;

		switch (kind)
		{
			case 'audio':
			{
				if (gotAudio)
					continue;

				gotAudio = true;
				break;
			}
			case 'video':
			{
				if (gotVideo)
					continue;

				gotVideo = true;
				break;
			}
			default:
			{
				continue;
			}
		}

		// Get codecs.
		for (const rtp of m.rtp)
		{
			const codec =
			{
				name                 : rtp.codec,
				mimeType             : `${kind}/${rtp.codec}`,
				kind                 : kind,
				clockRate            : rtp.rate,
				preferredPayloadType : rtp.payload,
				numChannels          : rtp.encoding || 1,
				rtcpFeedback         : [],
				parameters           : {}
			};

			codecsMap.set(codec.preferredPayloadType, codec);
		}

		// Get codec parameters.
		for (const fmtp of m.fmtp || [])
		{
			const parameters = sdpTransform.parseFmtpConfig(fmtp.config);
			const codec = codecsMap.get(fmtp.payload);

			if (!codec)
				continue;

			codec.parameters = parameters;
		}

		// Get RTCP feedback for each codec.
		for (const fb of m.rtcpFb || [])
		{
			const codec = codecsMap.get(fb.payload);

			if (!codec)
				continue;

			codec.rtcpFeedback.push(
				{
					parameter : fb.subtype || '',
					type      : fb.type
				});
		}

		// Get RTP header extensions.
		for (const ext of m.ext || [])
		{
			const preferredId = ext.value;
			const uri = ext.uri;
			const headerExtension =
			{
				kind,
				uri,
				preferredId
			};

			// Check if already present.
			const duplicated = headerExtensions
				.find((savedHeaderExtension) =>
				{
					return (
						headerExtension.kind === savedHeaderExtension.kind &&
						headerExtension.uri === savedHeaderExtension.uri
					);
				});

			if (duplicated)
				continue;

			headerExtensions.push(headerExtension);
		}
	}

	const rtpCapabilities =
	{
		codecs           : Array.from(codecsMap.values()),
		headerExtensions : headerExtensions,
		fecMechanisms    : [] // TODO
	};

	return rtpCapabilities;
}

/**
 * Extract DTLS parameters from a SDP.
 *
 * @param {Object} sdpObject - SDP Object generated by sdp-transform.
 * @return {RTCDtlsParameters}
 */
export function extractDtlsParameters(sdpObject)
{
	const media = getFirstActiveMediaSection(sdpObject);
	const fingerprint = media.fingerprint || sdpObject.fingerprint;
	let role;

	switch (media.setup)
	{
		case 'active':
			role = 'client';
			break;
		case 'passive':
			role = 'server';
			break;
		case 'actpass':
			role = 'auto';
			break;
	}

	const dtlsParameters =
	{
		role         : role,
		fingerprints :
		[
			{
				algorithm : fingerprint.type,
				value     : fingerprint.hash
			}
		]
	};

	return dtlsParameters;
}

/**
 * Extract RTP parameters from a SDP m section.
 *
 * @param {Object} mSection - SDP m section Object generated by sdp-transform.
 * @return {RTCRtpParameters}
 */
export function extractRtpParameters(mSection)
{
	const kind = mSection.type;

	// Map of RtpCodecParameters indexed by payload type.
	const codecsMap = new Map();

	// Array of RtpHeaderExtensions.
	const headerExtensions = [];

	// Get codecs.
	for (const rtp of mSection.rtp || [])
	{
		const codec =
		{
			name         : rtp.codec,
			mimeType     : `${kind}/${rtp.codec}`,
			clockRate    : rtp.rate,
			payloadType  : rtp.payload,
			numChannels  : rtp.encoding || 1,
			rtcpFeedback : [],
			parameters   : {}
		};

		codecsMap.set(codec.payloadType, codec);
	}

	// Get codec parameters.
	for (const fmtp of mSection.fmtp || [])
	{
		const parameters = sdpTransform.parseFmtpConfig(fmtp.config);
		const codec = codecsMap.get(fmtp.payload);

		if (!codec)
			continue;

		codec.parameters = parameters;
	}

	// Get RTCP feedback for each codec.
	for (const fb of mSection.rtcpFb || [])
	{
		const codec = codecsMap.get(fb.payload);

		if (!codec)
			continue;

		codec.rtcpFeedback.push(
			{
				parameter : fb.subtype || '',
				type      : fb.type
			});
	}

	// Get RTP header extensions.
	for (const ext of mSection.ext || [])
	{
		const headerExtension =
		{
			id  : ext.value,
			uri : ext.uri
		};

		headerExtensions.push(headerExtension);
	}

	const rtpParameters =
	{
		codecs           : Array.from(codecsMap.values()),
		headerExtensions : headerExtensions,
		encodings        : [], // TODO
		rtcp             : {}  // TODO
	};

	return rtpParameters;
}

/**
 * Get the first acive media section.
 *
 * @private
 * @param {Object} sdpObject - SDP Object generated by sdp-transform.
 * @return {Object} SDP media section as parsed by sdp-transform.
 */
function getFirstActiveMediaSection(sdpObject)
{
	return (sdpObject.media || [])
		.find((m) => m.iceUfrag && m.port !== 0);
}
